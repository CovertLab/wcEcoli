"""
Template for multigen analysis plots
"""

import pickle
import os

from matplotlib import pyplot as plt
# noinspection PyUnresolvedReferences
import numpy as np

from models.ecoli.analysis import multigenAnalysisPlot
from wholecell.analysis.analysis_tools import (exportFigure,
    read_bulk_molecule_counts, read_stacked_bulk_molecules, read_stacked_columns)
from wholecell.io.tablereader import TableReader


class Plot(multigenAnalysisPlot.MultigenAnalysisPlot):
    def do_plot(self, seedOutDir, plotOutDir, plotOutFileName, simDataFile, validationDataFile, metadata):
        with open(simDataFile, 'rb') as f:
            sim_data = pickle.load(f)
        with open(validationDataFile, 'rb') as f:
            validation_data = pickle.load(f)

        cell_paths = self.ap.get_cells()

        # Load data
        ## Simple stacking functions for data from all cells
        names = ['ATP[c]']  # Replace with desired list of names
        time = read_stacked_columns(cell_paths, 'Main', 'time')
        (counts,) = read_stacked_bulk_molecules(cell_paths, (names,))
        hi = 5

        # get a list of the molecules (monomers or complexes) that participate in complexation in some way based on the stoichiometry matrix (i.e., have a stoich greater than 0? via complexation.py)
        complex_IDs = sim_data.process.complexation.ids_complexes # should be the same as complex_names
        molecule_IDS = sim_data.process.complexation.molecule_names # these are the names of both complexes IDs and the IDs of monomers that participate in complexation reactions
        subunit_IDs = sim_data.process.complexation.subunit_names # these are the IDs of the monomers and complexes that are found within complexes

        # find what exists between both subunit_IDs and complex_IDs:
        complex_IDs_shared = [i for i in subunit_IDs if i in complex_IDs]

        # get the complex counts:
        complex_counts = read_stacked_bulk_molecules(cell_paths, complex_IDs)

        # get molecular weights of the monomers:
        mws = sim_data.process.translation.monomer_data['mw']
        ids = sim_data.process.translation.monomer_data['id']

        id_protein = ids[2342]
        id_protein_idx = np.where(ids == id_protein)[0][0]
        protein_mw = mws[id_protein_idx]
        protein_counts = complex_counts[:, id_protein_idx]

        # get the protein counts:
        protein_counts = read_stacked_bulk_molecules(cell_paths, [id_protein])












        # Or iterate on each cell if additional processing is needed
        for sim_dir in cell_paths:
            simOutDir = os.path.join(sim_dir, 'simOut')

            # Listeners used
            main_reader = TableReader(os.path.join(simOutDir, 'Main'))

            # Load data
            time = main_reader.readColumn('time')

            (counts,) = read_bulk_molecule_counts(simOutDir, (names,))

        plt.figure()

        ### Create Plot ###

        plt.tight_layout()
        exportFigure(plt, plotOutDir, plotOutFileName, metadata)
        plt.close('all')






# """ Temporarily added these so that I could see what could be accessed from sim data in terms of concentrations """
# 	# using Nora's concentration functions:
# 	def build_monomer_distribution_dict(monomer_set, monomer_complex_dict):
# 	# Dictionary of total monomer corresponding to free monomer ids
# 		total_monomer_dict = {name: [name] for name in monomer_set}
# 		for monomer_id, monomer_id_list in total_monomer_dict.items():
# 			print(monomer_id)
# 			list_complexes = monomer_complex_dict[monomer_id]
# 			if all(isinstance(item, str) for item in list_complexes):
# 				total_monomer_dict[monomer_id].extend(list_complexes)
# 		return total_monomer_dict
# 		def monomer_counts_and_concentration(cell_paths, total_monomer_dict):
#
# 			total_bulk_ids_to_check = list(chain(*total_monomer_dict.values()))
#
# 			# across timesteps
# 			counts_to_molar = read_stacked_columns(
# 				cell_paths, 'EnzymeKinetics', 'countsToMolar',
# 				remove_first=True, ignore_exception=True)
#
# 			# Get the free monomer and complex counts per cell
# 			# todo: check that I want the free monomers and not the total counts
# 			(detailed_counts,) = read_stacked_bulk_molecules(
# 				cell_paths, total_bulk_ids_to_check, ignore_exception=True, remove_first=True)
#
#
# 			detailed_conc = detailed_counts * counts_to_molar
# 			detailed_conc_avg = detailed_conc.mean(axis=0)
# 			detailed_conc_std = detailed_conc.std(axis=0)
#
# 			return  detailed_conc_avg, detailed_conc_std, total_bulk_ids_to_check
#
#
# 		# Extract  monomer data
# 		# read in the table generated by analysis/parca/monomer_to_complex_table.py
# 		monomers_to_complexes = pd.read_csv(monomers_to_complexes_path, sep='\t')
# 		monomer_complex_dict = monomers_to_complexes.groupby('monomer_id')['complex_id'].agg(
# 				list).to_dict()
#
# 		# todo: monomerIDs can be replaced with a smaller set, like just the lon substrates for example
# 		# I am not sure if all this info can be accessed within the actual simulation
# 		total_monomer_dict = build_monomer_distribution_dict(monomerIds, monomer_complex_dict)
#
# 		detailed_conc_avg, detailed_conc_std, monomers_and_complexes_names = monomer_counts_and_concentration(cell_paths, total_monomer_dict)
#
# 		""" End temporary addition """
#


if __name__ == '__main__':
    Plot().cli()
