"""
Template for cohort analysis plots
"""

import pickle
import os

from matplotlib import pyplot as plt
from matplotlib import cm
import numpy as np
import csv
import pandas as pd

from wholecell.utils import units
from models.ecoli.analysis import cohortAnalysisPlot
from wholecell.analysis.analysis_tools import (exportFigure, stacked_cell_identification,
	read_bulk_molecule_counts, read_stacked_bulk_molecules, read_stacked_columns)
from wholecell.io.tablereader import TableReader
from wholecell.containers.bulk_objects_container import BulkObjectsContainer

""" USER INPUTS """
# decide which generations to ignore, if any.
IGNORE_FIRST_N_GENS = 2
# decide what the threshold for molecules in complex/free monomer form is:
COMPLEX_THRESHOLD = .9
#Select monomers and associated with half lives equal or shorter than 3 hrs/180 min
half_life_threshold = 180
# path to table with monomer to complex info
# must first run analysis/parca/monomer_to_complex_table.py to generate table
monomers_to_complexes_path = 'out/pdr_CLClim3aNE_protease_assignment/kb_plot_out/monomer_to_complex_table_monomer_to_complex_assignment.tsv'

""" END USER INPUTS """
class Plot(cohortAnalysisPlot.CohortAnalysisPlot):
	def do_plot(self, variantDir, plotOutDir, plotOutFileName, simDataFile, validationDataFile, metadata):
		with open(simDataFile, 'rb') as f:
			sim_data = pickle.load(f)

		monomer_ids = sim_data.process.translation.monomer_data['id']
		monomer_id_to_index = {
			monomer_id: i for (i, monomer_id)
			in enumerate(monomer_ids)
		}

		# read in the table generated by analysis/parca/monomer_to_complex_table.py
		monomers_to_complexes = pd.read_csv(monomers_to_complexes_path, sep='\t')
		monomer_complex_dict = monomers_to_complexes.groupby('monomer_id')['complex_id'].agg(list).to_dict()
		complex_monomer_dict = monomers_to_complexes.groupby('complex_id')['monomer_id'].agg(list).to_dict()

		half_life_mask = monomers_to_complexes['total_monomer_half_life_(min)'] <= half_life_threshold
		complex_mask = monomers_to_complexes['complex_id'].notnull()
		protease_mask = monomers_to_complexes['monomer_protease_assignment'].notnull()
		always_monomers_df = monomers_to_complexes[half_life_mask][~complex_mask][protease_mask]
		as_complex_df = monomers_to_complexes[half_life_mask][complex_mask][protease_mask]

		as_monomers_id_set = set(always_monomers_df['monomer_id'].to_list())
		free_monomer_id_usually_complexed_set = set(as_complex_df['monomer_id'].to_list())
		complexes_ids_set = set(as_complex_df['complex_id'].to_list())

		# given these complexes have short half lives, extract all other monomers they may be associated with
		monomers_associated_to_complexes = []
		for complex_id in complexes_ids_set:
			monomer_list = complex_monomer_dict[complex_id]
			monomers_associated_to_complexes.extend(monomer_list)
		monomers_associated_to_complexes_set = set(monomers_associated_to_complexes)

		#check if these monomers are also in additional complexes that have longer half lives
		comp_monomers_associated_to_short_comp = []
		for monomer_id in monomers_associated_to_complexes_set:
			complex_list = monomer_complex_dict[monomer_id]
			comp_monomers_associated_to_short_comp.extend(complex_list)
		comp_monomers_associated_to_short_comp_set = set(comp_monomers_associated_to_short_comp)

		# filter these additional monomers and complexes by limiting to those assigned to proteases
		check_other_monomers_df = monomers_to_complexes[monomers_to_complexes['monomer_id'].isin(monomers_associated_to_complexes_set)][protease_mask]
		check_other_complexes_df = monomers_to_complexes[monomers_to_complexes['complex_id'].isin(comp_monomers_associated_to_short_comp_set)][protease_mask]
		other_free_monomer_id_usually_complexed_set = set(check_other_monomers_df['monomer_id'].to_list())
		other_complexes_ids_set = set(check_other_complexes_df['complex_id'].to_list())

		total_counts_ids_to_check = as_monomers_id_set.union(free_monomer_id_usually_complexed_set,
															 other_free_monomer_id_usually_complexed_set)

		total_bulk_ids_to_check = as_monomers_id_set.union(free_monomer_id_usually_complexed_set,
														   complexes_ids_set,
														   other_free_monomer_id_usually_complexed_set,
														   other_complexes_ids_set)

		total_monomer_indeces = np.array([
			monomer_id_to_index[monomer_id] for monomer_id in total_counts_ids_to_check
		])

		if self.ap.n_generation <= IGNORE_FIRST_N_GENS:
			print('Skipping analysis - not enough generations run.')
			return

		# Ignore data from predefined number of generations per seed
		all_cells = self.ap.get_cells(
			generation=np.arange(IGNORE_FIRST_N_GENS, self.ap.n_generation),
			only_successful=True)

		# Get the average total momomer counts per cell
		avg_total_counts = read_stacked_columns(all_cells, 'MonomerCounts',
												'monomerCounts',
												fun= lambda x: np.mean(x[:, total_monomer_indeces], axis=0),
												ignore_exception=True)

		avg_total_counts_df = pd.DataFrame(avg_total_counts, columns=list(total_counts_ids_to_check))

		# Get the average free monomer and complex counts per cell
		(detailed_counts,) = read_stacked_bulk_molecules(
			all_cells, total_bulk_ids_to_check, ignore_exception=True)

		cell_ids = stacked_cell_identification(all_cells, 'Main', 'time', ignore_exception=True)

		detailed_counts_df = pd.DataFrame(detailed_counts, columns = list(total_bulk_ids_to_check))
		detailed_counts_df['cell_id'] = cell_ids
		avg_detailed_counts_df = detailed_counts_df.groupby('cell_id').mean()

		#isolate monomers that function in monomer form, sanity check, these should be the same
		free_functional_monomers_df = avg_detailed_counts_df[list(as_monomers_id_set)]
		total_functional_monomers_df = avg_total_counts_df[list(as_monomers_id_set)]

		#isolate total cell counts of monomers that only function in complexes
		monomers_comp_of_interest = free_monomer_id_usually_complexed_set.union(other_free_monomer_id_usually_complexed_set)
		total_monomers_us_comp_df = avg_total_counts_df[list(monomers_comp_of_interest)]
		total_monomers_us_comp_df.columns = ['total_' + col for col in total_monomers_us_comp_df.columns]

		#isolate the detailed free monomer and complex monomer counts per cell
		free_mon_and_comps_df = avg_detailed_counts_df[list(total_bulk_ids_to_check)]

		total_and_detailed_complex_counts_df = pd.concat([total_monomers_us_comp_df, free_mon_and_comps_df], axis=1)

		import ipdb;
		ipdb.set_trace()




if __name__ == '__main__':
	Plot().cli()
