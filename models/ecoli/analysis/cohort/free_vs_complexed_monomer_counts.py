"""
Template for cohort analysis plots
"""

import pickle
import os

from matplotlib import pyplot as plt
from matplotlib import cm
import numpy as np
import csv
import pandas as pd

from wholecell.utils import units
from models.ecoli.analysis import cohortAnalysisPlot
from wholecell.analysis.analysis_tools import (exportFigure, stacked_cell_identification,
	read_bulk_molecule_counts, read_stacked_bulk_molecules, read_stacked_columns)
from wholecell.io.tablereader import TableReader
from wholecell.containers.bulk_objects_container import BulkObjectsContainer

""" USER INPUTS """
# decide which generations to ignore, if any.
IGNORE_FIRST_N_GENS = 2
# decide what the threshold for molecules in complex/free monomer form is:
COMPLEX_THRESHOLD = .9
#Select monomers and associated with half lives equal or shorter than 3 hrs/180 min
half_life_threshold = 180
# path to table with monomer to complex info
# must first run analysis/parca/monomer_to_complex_table.py to generate table
monomers_to_complexes_path = 'out/pdr_CLClim3aNE_protease_assignment/kb_plot_out/monomer_to_complex_table_monomer_to_complex_assignment.tsv'

""" END USER INPUTS """
class Plot(cohortAnalysisPlot.CohortAnalysisPlot):
	def do_plot(self, variantDir, plotOutDir, plotOutFileName, simDataFile, validationDataFile, metadata):
		with open(simDataFile, 'rb') as f:
			sim_data = pickle.load(f)

		monomer_ids = sim_data.process.translation.monomer_data['id']
		monomer_id_to_index = {
			monomer_id: i for (i, monomer_id)
			in enumerate(monomer_ids)
		}

		# read in the table generated by analysis/parca/monomer_to_complex_table.py
		monomers_to_complexes = pd.read_csv(monomers_to_complexes_path, sep='\t')
		monomer_complex_dict = monomers_to_complexes.groupby('monomer_id')['complex_id'].agg(list).to_dict()
		complex_monomer_dict = monomers_to_complexes.groupby('complex_id')['monomer_id'].agg(list).to_dict()

		# Select monomers based on their function as free monomer or if they function in a complex
		# And their short half life and only if they have a protease assigned
		half_life_mask = monomers_to_complexes['total_monomer_half_life_(min)'] <= half_life_threshold
		complex_mask = monomers_to_complexes['complex_id'].notnull()
		protease_mask = monomers_to_complexes['monomer_protease_assignment'].notnull()
		always_monomers_df = monomers_to_complexes[half_life_mask][~complex_mask][protease_mask]
		as_complex_df = monomers_to_complexes[half_life_mask][complex_mask][protease_mask]

		as_monomers_id_set = set(always_monomers_df['monomer_id'].to_list())
		free_monomer_id_usually_complexed_set = set(as_complex_df['monomer_id'].to_list())
		complexes_ids_set = set(as_complex_df['complex_id'].to_list())

		# Given these complexes have short half lives, extract all other monomers they may be associated with
		monomers_associated_to_complexes = []
		for complex_id in complexes_ids_set:
			monomer_list = complex_monomer_dict[complex_id]
			monomers_associated_to_complexes.extend(monomer_list)
		monomers_associated_to_complexes_set = set(monomers_associated_to_complexes)

		# Check if these monomers are also in additional complexes that have longer half lives
		comp_monomers_associated_to_short_comp = []
		for monomer_id in monomers_associated_to_complexes_set:
			complex_list = monomer_complex_dict[monomer_id]
			comp_monomers_associated_to_short_comp.extend(complex_list)
		comp_monomers_associated_to_short_comp_set = set(comp_monomers_associated_to_short_comp)

		# Filter these additional monomers and complexes by limiting to those assigned to proteases
		check_other_monomers_df = monomers_to_complexes[monomers_to_complexes['monomer_id'].isin(monomers_associated_to_complexes_set)][protease_mask]
		check_other_complexes_df = monomers_to_complexes[monomers_to_complexes['complex_id'].isin(comp_monomers_associated_to_short_comp_set)][protease_mask]
		other_free_monomer_id_usually_complexed_set = set(check_other_monomers_df['monomer_id'].to_list())
		other_complexes_ids_set = set(check_other_complexes_df['complex_id'].to_list())


		# Monomers of interest that only function in complexes
		monomers_comp_of_interest = free_monomer_id_usually_complexed_set.union(
			other_free_monomer_id_usually_complexed_set)

		# All monomers of interest
		total_counts_ids_to_check = as_monomers_id_set.union(free_monomer_id_usually_complexed_set,
											 other_free_monomer_id_usually_complexed_set)

		# Ids of all monomers and complexes
		total_bulk_ids_to_check = as_monomers_id_set.union(free_monomer_id_usually_complexed_set,
														   complexes_ids_set,
														   other_free_monomer_id_usually_complexed_set,
														   other_complexes_ids_set)

		total_monomer_indeces = np.array([
			monomer_id_to_index[monomer_id] for monomer_id in total_counts_ids_to_check
		])

		if self.ap.n_generation <= IGNORE_FIRST_N_GENS:
			print('Skipping analysis - not enough generations run.')
			return

		# Ignore data from predefined number of generations per seed
		all_cells = self.ap.get_cells(
			generation=np.arange(IGNORE_FIRST_N_GENS, self.ap.n_generation),
			only_successful=True)

		#get ratios of monomer complexation and free form
		total_counts = read_stacked_columns(all_cells, 'MonomerCounts',
												'monomerCounts',
												fun=lambda x: x[:, total_monomer_indeces], ignore_exception=True)

		total_counts_df = pd.DataFrame(total_counts, columns=list(total_counts_ids_to_check))

		# Get the free monomer and complex counts per cell
		(detailed_counts,) = read_stacked_bulk_molecules(
			all_cells, total_bulk_ids_to_check, ignore_exception=True)

		detailed_counts_df = pd.DataFrame(detailed_counts, columns = list(total_bulk_ids_to_check))

		def isolate_total_and_distributed_monomers(total_counts_df, detailed_counts_df, monomer_set, monomer_forms_set):
			total_monomers_df = total_counts_df[list(monomer_set)]
			total_monomers_df.columns = ['total_' + col for col in total_monomers_df.columns]
			free_monomers_df = detailed_counts_df[list(monomer_forms_set)]
			total_and_free_monomer_counts_df = pd.concat([total_monomers_df, free_monomers_df], axis=1)
			return total_and_free_monomer_counts_df

		def build_monomer_distribution_dict(monomer_set, monomer_complex_dict):
			# Dictionary of total monomer corresponding to free monomer ids
			total_monomer_dict = {'total_' + name: [name] for name in monomer_set}
			for total_monomer, monomer_id_list in total_monomer_dict.items():
				monomer_id = monomer_id_list[0]
				list_complexes = monomer_complex_dict[monomer_id]
				if all(isinstance(item, str) for item in list_complexes):
					total_monomer_dict[total_monomer].extend(list_complexes)
			return total_monomer_dict

		def get_monomer_stoich(monomers_to_complexes, monomer_id, form):
			stoich = monomers_to_complexes[(monomers_to_complexes['monomer_id'] == monomer_id)
										   & (monomers_to_complexes['complex_id'] == form)][
				'monomers_per_complex'].values[0]
			return stoich

		def find_monomer_distribution(total_counts_df, detailed_counts_df,
									  monomer_set, monomer_forms_set,
									  monomer_complex_dict, monomers_to_complexes):
			monomer_distribution_df = isolate_total_and_distributed_monomers(total_counts_df, detailed_counts_df,
																			 monomer_set, monomer_forms_set)
			total_monomer_dict = build_monomer_distribution_dict(monomer_set, monomer_complex_dict)
			for total_monomer, existing_monomer_forms in total_monomer_dict.items():
				monomer_id = existing_monomer_forms[0]
				monomer_distribution_df[monomer_id] = monomer_distribution_df[monomer_id] / monomer_distribution_df[
					total_monomer]
				if len(existing_monomer_forms) >1:
					for form in existing_monomer_forms[1:]:
						stoich = get_monomer_stoich(monomers_to_complexes, monomer_id, form)
						monomer_complex_name = form + '_' + monomer_id
						monomer_distribution_df[monomer_complex_name] = (monomer_distribution_df[form] * stoich) / monomer_distribution_df[
																			total_monomer]
			# Edit dicitionary of monomers to complexes by adding monomer name at the end of each complex
			for total_monomer, forms in total_monomer_dict.items():
				if len(forms) > 1:
					for i in range(1, len(forms)):
						forms[i] = forms[i] + '_' + forms[0]
			return monomer_distribution_df, total_monomer_dict

		monomer_complex_distribution_df, total_monomer_complex_id_dict = find_monomer_distribution(total_counts_df, detailed_counts_df,
															monomers_comp_of_interest, total_bulk_ids_to_check,
															monomer_complex_dict,monomers_to_complexes)

		monomer_without_complex_distribution_df, total_monomer_free_id_dict = find_monomer_distribution(total_counts_df, detailed_counts_df,
																	as_monomers_id_set, as_monomers_id_set,
																	monomer_complex_dict, monomers_to_complexes)


		cell_ids = stacked_cell_identification(all_cells, 'Main', 'time', ignore_exception=True)
		monomer_complex_distribution_df['cell_id'] = cell_ids
		monomer_without_complex_distribution_df['cell_id'] = cell_ids

		avg_ratios_complex_df = monomer_complex_distribution_df.groupby('cell_id').mean()
		avg_ratios_without_complex_df = monomer_without_complex_distribution_df.groupby('cell_id').mean()

		def plot_bar_graphs_per_monomer(df, total_monomer_dict, figsize=(10, 40)):
			num_groups = len(total_monomer_dict)
			cols = 4  # Number of columns for the grid
			rows = (num_groups + cols - 1) // cols  # Calculate the number of rows

			fig, axes = plt.subplots(nrows=rows, ncols = cols, figsize = figsize, sharex = False)
			for i, (group_name, columns) in enumerate(sorted(total_monomer_dict.items())):
				row = i // cols
				col = i % cols
				ax = axes[row, col]  # Get the current subplot axis

				means = df[columns].mean(axis=0)  # Calculate the mean across rows for each column
				errors = df[columns].std(axis=0) / np.sqrt(len(df))  # Calculate standard error
				means.plot.bar(ax=ax, yerr=errors, capsize=4, legend=False)
				ax.set_title(group_name[:-3], fontsize=10)
				ax.set_ylabel('Fraction of total monomer')
				short_labels = [name[:12] for name in columns]
				ax.set_xticklabels(short_labels, rotation=45, ha='right')
			# Remove any empty subplots
			for i in range(num_groups, rows * cols):
				fig.delaxes(axes.flat[i])

			plt.tight_layout()

		plot_bar_graphs_per_monomer(avg_ratios_complex_df, total_monomer_complex_id_dict, figsize=(10, 20))
		exportFigure(plt, plotOutDir, plotOutFileName + '_complexed_monomer_distribution', metadata)

		plot_bar_graphs_per_monomer(avg_ratios_without_complex_df, total_monomer_free_id_dict, figsize=(10, 20))
		exportFigure(plt, plotOutDir, plotOutFileName + '_free_monomer_distribution', metadata)

		plt.close('all')



if __name__ == '__main__':
	Plot().cli()
