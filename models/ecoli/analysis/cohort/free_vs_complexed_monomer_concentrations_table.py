"""
Given the tsv file generated by analysis/parca/monomer_to_complex_table.py exists (specified under "monomers_to_complexes_path" variable),
this cohort analysis script identifies the average counts and concentrations of these monomers per time step
across the forms in which they are found in the cell, either as free monomer or in complexed forms.


"""

import pickle
import os

from matplotlib import pyplot as plt
from matplotlib import cm
import numpy as np
import csv
import pandas as pd
from itertools import chain

from wholecell.utils import units
from models.ecoli.analysis import cohortAnalysisPlot
from wholecell.analysis.analysis_tools import (exportFigure, stacked_cell_identification,
	read_bulk_molecule_counts, read_stacked_bulk_molecules, read_stacked_columns)
from wholecell.io.tablereader import TableReader
from wholecell.containers.bulk_objects_container import BulkObjectsContainer

""" USER INPUTS """
# Decide which generations to ignore, if any.
IGNORE_FIRST_N_GENS = 2
# Path to table with monomer to complex info
# Must first run analysis/parca/monomer_to_complex_table.py to generate table
monomers_to_complexes_path = 'out/pdr_CLClim3aNE_protease_assignment/kb_plot_out/monomer_to_complex_table_monomer_to_complex_assignment.tsv'
# List monomer ids for which dynamic monomer and mRNA counts are of interest
monomer_short_list = ['PD03938[c]', 'G6890-MONOMER[c]', 'G6737-MONOMER[c]',
					  'RPOD-MONOMER[c]', 'PD02936[c]', 'RED-THIOREDOXIN2-MONOMER[c]',
					  'EG10542-MONOMER[c]']

""" END USER INPUTS """
class Plot(cohortAnalysisPlot.CohortAnalysisPlot):
	def do_plot(self, variantDir, plotOutDir, plotOutFileName, simDataFile, validationDataFile, metadata):
		with open(simDataFile, 'rb') as f:
			sim_data = pickle.load(f)

		# Ignore data from predefined number of generations per seed
		if self.ap.n_generation <= IGNORE_FIRST_N_GENS:
			print('Skipping analysis - not enough generations run.')
			return

		# read in the table generated by analysis/parca/monomer_to_complex_table.py
		monomers_to_complexes = pd.read_csv(monomers_to_complexes_path, sep='\t')
		monomer_complex_dict = monomers_to_complexes.groupby('monomer_id')['complex_id'].agg(list).to_dict()


		def build_monomer_distribution_dict(monomer_set, monomer_complex_dict):
			# Dictionary of total monomer corresponding to free monomer ids
			total_monomer_dict = {name: [name] for name in monomer_set}
			for monomer_id, monomer_id_list in total_monomer_dict.items():
				list_complexes = monomer_complex_dict[monomer_id]
				if all(isinstance(item, str) for item in list_complexes):
					total_monomer_dict[monomer_id].extend(list_complexes)
			return total_monomer_dict


		def monomer_counts_and_concentration(cell_paths, total_monomer_dict):

			total_bulk_ids_to_check = list(chain(*total_monomer_dict.values()))

			# across timesteps
			counts_to_molar = read_stacked_columns(
				cell_paths, 'EnzymeKinetics', 'countsToMolar',
				remove_first=True, ignore_exception=True)

			# Get the free monomer and complex counts per cell
			(detailed_counts,) = read_stacked_bulk_molecules(
				cell_paths, total_bulk_ids_to_check, ignore_exception=True, remove_first=True)


			detailed_conc = detailed_counts * counts_to_molar
			detailed_conc_avg = detailed_conc.mean(axis=0)
			detailed_conc_std = detailed_conc.std(axis=0)

			return  detailed_conc_avg, detailed_conc_std, total_bulk_ids_to_check


		# Extract  monomer data
		total_monomer_dict = build_monomer_distribution_dict(monomer_short_list, monomer_complex_dict)


		cell_paths = self.ap.get_cells(
			generation=np.arange(IGNORE_FIRST_N_GENS, self.ap.n_generation),
			only_successful=True)
		detailed_conc_avg, detailed_conc_std, monomers_and_complexes_names = monomer_counts_and_concentration(cell_paths, total_monomer_dict)

		# Write data to table
		with open(os.path.join(plotOutDir, plotOutFileName + '.tsv'), 'w') as f:
			writer = csv.writer(f, delimiter='\t')
			writer.writerow([
				'protein_id',
				'average_concentration', 'standard_deviation',
			])

			for i in range(len(monomers_and_complexes_names)):
				writer.writerow([
					monomers_and_complexes_names[i][:-3], detailed_conc_avg[i],
					detailed_conc_std[i]
				])


if __name__ == '__main__':
	Plot().cli()
