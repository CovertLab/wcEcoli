"""
Calculate complex counts and compare for monomers that appear in complexes
"""

# todo: for now this calls from pre-made tables generated by a script in a different branch, change later when merged with master

import pickle
import os
import pandas as pd
from matplotlib import pyplot as plt
# noinspection PyUnresolvedReferences
import numpy as np

from models.ecoli.analysis import cohortAnalysisPlot
from wholecell.analysis.analysis_tools import (exportFigure,
	read_bulk_molecule_counts, read_stacked_bulk_molecules, read_stacked_columns)
from wholecell.io.tablereader import TableReader

""" USER INPUTS """
# decide which generations to ignore, if any.
IGNORE_FIRST_N_GENS = 2
# decide what the threshold for molecules in complex/free monomer form is:
THRESHOLD = -1

# path to tables made in the ____ file:
monomers_in_multiple_complexes_table_path = '~/wcEcoli/out/CLClim3NE/wildtype_000000/plotOut/free_vs_complexed_monomer_countsmonomers_in_multiple_protein_complexes.tsv'
monomers_in_one_complex_path = '~/wcEcoli/out/CLClim3NE/wildtype_000000/plotOut/free_vs_complexed_monomer_countsMonomers_in_one_complex.tsv'
monomers_in_zero_complexes_path = '~/wcEcoli/out/CLClim3NE/wildtype_000000/plotOut/free_vs_complexed_monomer_countsMonomers_not_in_complex.tsv'

# read in the tables
monomers_in_multiple_complexes = pd.read_csv(monomers_in_multiple_complexes_table_path, sep='\t')
monomers_in_one_complex = pd.read_csv(monomers_in_one_complex_path, sep='\t')
monomers_in_zero_complexes = pd.read_csv(monomers_in_zero_complexes_path, sep='\t')

""" END USER INPUTS """

class Plot(cohortAnalysisPlot.CohortAnalysisPlot):
	def generate_data(self, simDataFile):
		"""
        Generates csv files of protein count data from simulations
        Args:
            simDataFile: simulation data file
        Returns:
            #TODO: update this description
            protein_counts: protein count (PC) data for all proteins (originally
             present on the E.coli chromosome) in the simulation for each variant
              (the PC for each protein is averaged over all the generations)
            self.total_protein_counts: the original PCs and new gene (NG) PCs
            in one variable
            self.new_gene_monomer_ids: protein ids for new genes inserted into
            the E.coli genome
            self.original_gene_ids: protein ids for the original proteins on
            the E.coli genome
            self.all_monomer_ids: list of all the monomer ids (NG protein ids
            and orginal proteins' gene ids)
        """
		with open(simDataFile, 'rb') as f:
			sim_data = pickle.load(f)
		monomer_sim_data = (
			sim_data.process.translation.monomer_data.struct_array)
		self.all_monomer_ids = monomer_sim_data['id']

		# Get the paths for all cells:
		all_cells = self.ap.get_cells(
			generation=np.arange(IGNORE_FIRST_N_GENS, self.n_total_gens),
			only_successful=True)

		# Get the average total protein counts for each monomer:
		total_counts = (
			read_stacked_columns(all_cells, 'MonomerCounts',
								 'monomerCounts', ignore_exception=True))
		avg_total_counts = np.mean(total_counts, axis=0)

		# Get the average free protein counts for each monomer:
		(free_counts,) = read_stacked_bulk_molecules(
			all_cells, self.all_monomer_ids, ignore_exception=True)
		avg_free_counts = np.mean(free_counts, axis=0)

		# Get the average complex counts for each monomer:
		avg_complex_counts = avg_total_counts - avg_free_counts

		#
		hi = 5


		return avg_total_counts, avg_free_counts, avg_complex_counts

	def determine_fraction_table(self, simDataFile):
		"""
		Determines the fraction of proteins in complex form for each monomer
		Args:
			simDataFile: simulation data file
		Returns:
			complex_fraction: fraction of proteins in complex form for each monomer
		"""
		# Obtain counts data:
		avg_total_counts, avg_free_counts, avg_complex_counts = self.generate_data(
			simDataFile)
		# Remove the last three characters from each value:
		monomer_ids = [id[:-3] for id in self.all_monomer_ids]

		# Calculate the faction in complex and in free from:
		complex_fraction = np.zeros(len(monomer_ids))
		free_fraction = np.zeros(len(monomer_ids))
		for i in range(len(monomer_ids)):
			if avg_total_counts[i] == 0:
				complex_fraction[i] = 0 # set to zero so it is still accounted for
				free_fraction[i] = 0
				print('Monomer ID:', monomer_ids[i], 'has no total counts')
			else:
				complex_fraction[i] = avg_complex_counts[i] / avg_total_counts[i]
				free_fraction[i] = avg_free_counts[i] / avg_total_counts[i]


		# make a table of the monomers and their counts and their fractions:
		monomer_counts = pd.DataFrame({'Monomer ID': monomer_ids,
									   'Total Counts': avg_total_counts,
									   'Free Counts': avg_free_counts,
									   'Free Fraction': free_fraction,
									   'Complex Counts': avg_complex_counts,
									   'Complex Fraction': complex_fraction})

		return monomer_counts

	def determine_complex_fraction(self, simDataFile, table):
		"""
		Determines how many proteins have a fraction of proteins in complex form above the threshold and under it
		Args:
			simDataFile:
			table:

		Returns:

		"""
		# print the original table length:
		print('original table length:', len(table))

		# Obtain the fraction table:
		full_counts_table = self.determine_fraction_table(simDataFile)
		# note that some are set to zero automatically so they are not discarded. oddly, there are some classified as having zero complexes but still show a complexed fraction (nonzero). so in order to see these, run a blank with -1 as the threshold

		# merge the two tables:
		merged_table = pd.merge(full_counts_table, table, left_on='Monomer ID',
			right_on='monomer_id', how='inner')
		merged_table = merged_table.drop(columns=['monomer_id'])
		print('merged table length:', len(merged_table))

		# Generate a new table for the proteins that have a complex fraction value above the threshold:
		complex_threshold = merged_table[merged_table['Complex Fraction'] > THRESHOLD]
		complex_threshold = complex_threshold.reset_index(drop=True)
		print('# of proteins with complex fractions above the threshold:', len(complex_threshold))

		# Generate a new table for the proteins that have a free fraction value above the threshold:
		free_threshold = merged_table[merged_table['Free Fraction'] > THRESHOLD]
		free_threshold = free_threshold.reset_index(drop=True)
		print('# of proteins with free fractions above the threshold:', len(free_threshold))

		# Generate a new table for the proteins that have a complex fraction value below the threshold:
		complex_below_threshold = merged_table[merged_table['Complex Fraction'] <= THRESHOLD]
		complex_below_threshold = complex_below_threshold.reset_index(drop=True)
		print('# of proteins with complex fractions below the threshold:', len(complex_below_threshold))

		# Generate a new table for the proteins that have a free fraction value below the threshold:
		free_below_threshold = merged_table[merged_table['Free Fraction'] <= THRESHOLD]
		free_below_threshold = free_below_threshold.reset_index(drop=True)
		print('# of proteins with free fractions below the threshold:', len(free_below_threshold))

		# Generate a new table for the proteins that have both fractions under the threshold:
		below_threshold = merged_table[(merged_table['Complex Fraction'] <= THRESHOLD) & (merged_table['Free Fraction'] <= THRESHOLD)]
		below_threshold = below_threshold.reset_index(drop=True)
		print('# of proteins with both fractions below the threshold:', len(below_threshold))

		# figure out which monomers from the merged_table do not show up in the free_threshold, complex_threshold, or below_threshold tables:
		free_threshold_ids_set = set(free_threshold['Monomer ID'])
		complex_threshold_ids_set = set(complex_threshold['Monomer ID'])
		below_threshold_ids_set = set(below_threshold['Monomer ID'])
		all_threshold_ids = free_threshold_ids_set | complex_threshold_ids_set | below_threshold_ids_set

		# Find missing IDs that are not in the tables of interest:
		missing_ids = [id for id in merged_table['Monomer ID'] if id not in all_threshold_ids]
		print('missing ids:', missing_ids)
		print('number of missing ids:', len(missing_ids))

		return complex_threshold, free_threshold, below_threshold

	def create_full_table(self, simDataFile, zero_complex_table, one_complex_table, multiple_complex_table):

		full_counts_table = self.determine_fraction_table(simDataFile)
		# create a new column for the complex type:
		full_counts_table['Complex Type'] = 'none'
		# assign the complex type to the table:
		full_counts_table.loc[full_counts_table['Monomer ID'].isin(zero_complex_table['monomer_id']), 'Complex Type'] = 'zero'
		full_counts_table.loc[full_counts_table['Monomer ID'].isin(one_complex_table['monomer_id']), 'Complex Type'] = 'one'
		full_counts_table.loc[full_counts_table['Monomer ID'].isin(multiple_complex_table['monomer_id']), 'Complex Type'] = 'multiple'
		return full_counts_table




	def do_plot(self, variantDir, plotOutDir, plotOutFileName, simDataFile, validationDataFile, metadata):
		# Get the paths for all cells:

		self.n_total_gens = self.ap.n_generation

		# todo: there might be some slight mismatches becuase of different ecocyc update versions?
		# generate data for monomers in multiple complexes:
		print('Table of interest: monomers in multiple complexes')
		complex_threshold_m, free_threshold_m, below_threshold_m = (
			self.determine_complex_fraction(simDataFile,
											monomers_in_multiple_complexes))

		# generate data for monomers in one complex:
		print('Table of interest: monomers in one complex')
		complex_threshold_1, free_threshold_1, below_threshold_1 = (
			self.determine_complex_fraction(simDataFile,
											monomers_in_one_complex))

		# generate data for monomers in zero complexes:
		print('Table of interest: monomers in no complexes')
		complex_threshold_0, free_threshold_0, below_threshold_0 = (
			self.determine_complex_fraction(simDataFile,
											monomers_in_zero_complexes))

		# save the tables:
		save_path = os.path.join(plotOutDir, 'complex_classifications_preParca')
		monomers_in_multiple_complexes_path = os.path.join(save_path, 'monomers_in_multiple_complexes')
		monomers_in_one_complex_path = os.path.join(save_path, 'monomers_in_one_complex')
		monomers_in_zero_complexes_path = os.path.join(save_path, 'monomers_in_zero_complexes')
		if not os.path.exists(save_path):
			os.makedirs(save_path)
			if not os.path.exists(monomers_in_multiple_complexes_path):
				os.makedirs(monomers_in_multiple_complexes_path)
			if not os.path.exists(monomers_in_one_complex_path):
				os.makedirs(monomers_in_one_complex_path)
			if not os.path.exists(monomers_in_zero_complexes_path):
				os.makedirs(monomers_in_zero_complexes_path)

		# name the tables:
		complex_threshold_name = 'above_complex_threshold_' + str(THRESHOLD) + '.csv'
		free_threshold_name = 'above_free_threshold_' + str(THRESHOLD) + '.csv'
		below_threshold_name = 'both_below_threshold_' + str(THRESHOLD) + '.csv'
		# save the tables:
		complex_threshold_m.to_csv(os.path.join(monomers_in_multiple_complexes_path, complex_threshold_name))
		free_threshold_m.to_csv(os.path.join(monomers_in_multiple_complexes_path, free_threshold_name))
		below_threshold_m.to_csv(os.path.join(monomers_in_multiple_complexes_path, below_threshold_name))
		complex_threshold_1.to_csv(os.path.join(monomers_in_one_complex_path, complex_threshold_name))
		free_threshold_1.to_csv(os.path.join(monomers_in_one_complex_path, free_threshold_name))
		below_threshold_1.to_csv(os.path.join(monomers_in_one_complex_path, below_threshold_name))
		complex_threshold_0.to_csv(os.path.join(monomers_in_zero_complexes_path, complex_threshold_name))
		free_threshold_0.to_csv(os.path.join(monomers_in_zero_complexes_path, free_threshold_name))
		below_threshold_0.to_csv(os.path.join(monomers_in_zero_complexes_path, below_threshold_name))

		# save the full counts table:
		full_counts_table = self.create_full_table(simDataFile,
			monomers_in_zero_complexes, monomers_in_one_complex, monomers_in_multiple_complexes)
		full_counts_table.to_csv(os.path.join(save_path, 'full_counts_table.csv'))
		print('full counts table saved to:', os.path.join(save_path, 'full_counts_table.csv'))



if __name__ == '__main__':
	Plot().cli()
